@using Apolo.Core.Model.Treatment
@{
    ViewBag.Title = "Jugando Pong";
    var workUnit = ViewBag.WorkUnit as WorkUnit;
}

<canvas id="canvas" style="position: absolute; left: 50%; top: 3%; transform: translate(-50%, 0);"></canvas>
<audio preload="true" id="collide">
    <source src="~/Assets/games/pong/bounce.wav" />
</audio>

<div id="clock" style="box-shadow: 15px 15px 10px rgba(0, 0, 0, 0.2);">

</div>

<div id="completion-message" style="display: none; box-shadow: 15px 15px 10px rgba(0, 0, 0, 0.2);">
    Completado!&nbsp;&nbsp;&nbsp;<a href="@Url.Action("Index", "Home", new { @area = "Patient" })" class="waves-effect waves-light btn"><i class="material-icons left">done</i>Regresar</a>
</div>

@section scripts {
    <script>
        var _finalScore = 0;
        var countIMU = 0;
        var countEMG = 0;

        var _lowAccelY = Number.MAX_VALUE;
        var _highAccelY = Number.MIN_VALUE;
        var _avgAccelY = 0;

        var _lowRomY = Number.MAX_VALUE;
        var _highRomY = Number.MIN_VALUE;
        var _avgRomY = 0;

        var _lowPod0 = Number.MAX_VALUE;
        var _highPod0 = Number.MIN_VALUE;
        var _avgPod0 = 0;

        var _lowPod1 = Number.MAX_VALUE;
        var _highPod1 = Number.MIN_VALUE;
        var _avgPod1 = 0;

        var _lowPod2 = Number.MAX_VALUE;
        var _highPod2 = Number.MIN_VALUE;
        var _avgPod2 = 0;

        var _lowPod3 = Number.MAX_VALUE;
        var _highPod3 = Number.MIN_VALUE;
        var _avgPod3 = 0;

        var _lowPod4 = Number.MAX_VALUE;
        var _highPod4 = Number.MIN_VALUE;
        var _avgPod4 = 0;

        var _lowPod5 = Number.MAX_VALUE;
        var _highPod5 = Number.MIN_VALUE;
        var _avgPod5 = 0;

        var _lowPod6 = Number.MAX_VALUE;
        var _highPod6 = Number.MIN_VALUE;
        var _avgPod6 = 0;

        var _lowPod7 = Number.MAX_VALUE;
        var _highPod7 = Number.MIN_VALUE;
        var _avgPod7 = 0;

        function processIMU(data) {
            countIMU++;

            _lowAccelY = Math.min(_lowAccelY, data.accelerometer.y);
            _highAccelY = Math.max(_highAccelY, data.accelerometer.y);
            _avgAccelY = (_avgAccelY * (countIMU - 1) + Math.abs(data.accelerometer.y)) / countIMU;

            _lowRomY = Math.min(_lowRomY, data.gyroscope.y);
            _highRomY = Math.max(_highRomY, data.gyroscope.y);
            _avgRomY = (_avgRomY * (countIMU - 1) + Math.abs(data.gyroscope.y)) / countIMU;
        }

        function processEMG(data) {
            countEMG++;

            _lowPod0 = Math.min(_lowPod0, data[0]);
            _highPod0 = Math.max(_highPod0, data[0]);
            _avgPod0 = (_avgPod0 * (countEMG - 1) + Math.abs(data[0])) / countEMG;

            _lowPod1 = Math.min(_lowPod1, data[1]);
            _highPod1 = Math.max(_highPod1, data[1]);
            _avgPod1 = (_avgPod1 * (countEMG - 1) + Math.abs(data[1])) / countEMG;

            _lowPod2 = Math.min(_lowPod2, data[2]);
            _highPod2 = Math.max(_highPod2, data[2]);
            _avgPod2 = (_avgPod2 * (countEMG - 1) + Math.abs(data[2])) / countEMG;

            _lowPod3 = Math.min(_lowPod3, data[3]);
            _highPod3 = Math.max(_highPod3, data[3]);
            _avgPod3 = (_avgPod3 * (countEMG - 1) + Math.abs(data[3])) / countEMG;

            _lowPod4 = Math.min(_lowPod4, data[4]);
            _highPod4 = Math.max(_highPod4, data[4]);
            _avgPod4 = (_avgPod4 * (countEMG - 1) + Math.abs(data[4])) / countEMG;

            _lowPod5 = Math.min(_lowPod5, data[5]);
            _highPod5 = Math.max(_highPod5, data[5]);
            _avgPod5 = (_avgPod5 * (countEMG - 1) + Math.abs(data[5])) / countEMG;

            _lowPod6 = Math.min(_lowPod6, data[6]);
            _highPod6 = Math.max(_highPod6, data[6]);
            _avgPod6 = (_avgPod6 * (countEMG - 1) + Math.abs(data[6])) / countEMG;

            _lowPod7 = Math.min(_lowPod7, data[7]);
            _highPod7 = Math.max(_highPod7, data[7]);
            _avgPod7 = (_avgPod7 * (countEMG - 1) + Math.abs(data[7])) / countEMG;
        }
    </script>

    <script type="text/javascript">
        function getUnitDurationInMinutes() {
            return new Date(new Date().valueOf() + @workUnit.DurationInMinutes * 60 * 1000);
                }

                var $clock = $('#clock');

                $clock.countdown(getUnitDurationInMinutes(), function (event) {
                    $(this).html(event.strftime('%M:%S'));
                })
                .on("finish.countdown", function () {
            var _workUnitId = '@workUnit.ID';
            $.post('@Url.Action("CompleteWorkUnit", "Play", new { @area = "Patient" })',
                {
                    workUnitId: _workUnitId,
                    finalScore: _finalScore,

                    LowAccelY: _lowAccelY * 20,
                    HighAccelY: _highAccelY * 20,
                    AvgAccelY: _avgAccelY * 20,

                    LowRomY: _lowRomY * 20,
                    HighRomY: _highRomY * 20,
                    AvgRomY: _avgRomY * 20,

                    LowPod0: _lowPod0 * 20,
                    HighPod0: _highPod0 * 20,
                    AvgPod0: _avgPod0 * 20,

                    LowPod1: _lowPod1 * 20,
                    HighPod1: _highPod1 * 20,
                    AvgPod1: _avgPod1 * 20,

                    LowPod2: _lowPod2 * 20,
                    HighPod2: _highPod2 * 20,
                    AvgPod2: _avgPod2 * 20,

                    LowPod3: _lowPod3 * 20,
                    HighPod3: _highPod3 * 20,
                    AvgPod3: _avgPod3 * 20,

                    LowPod4: _lowPod4 * 20,
                    HighPod4: _highPod4 * 20,
                    AvgPod4: _avgPod4 * 20,

                    LowPod5: _lowPod5 * 20,
                    HighPod5: _highPod5 * 20,
                    AvgPod5: _avgPod5 * 20,

                    LowPod6: _lowPod6 * 20,
                    HighPod6: _highPod6 * 20,
                    AvgPod6: _avgPod6 * 20,

                    LowPod7: _lowPod7 * 20,
                    HighPod7: _highPod7 * 20,
                    AvgPod7: _avgPod7 * 20
                },
                function () {
                    $("#clock").hide();
                    $("#completion-message").show();
                }
            );
        });

                //$clock.countdown('pause');
    </script>
    @Scripts.Render("~/Assets/plugins/myo/js/myo.js")
    <script>

        // RequestAnimFrame: a browser API for getting smooth animations
        window.requestAnimFrame = (function () {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function (callback) {
                    return window.setTimeout(callback, 1000 / 60);
                };
        })();

        window.cancelRequestAnimFrame = (function () {
            return window.cancelAnimationFrame ||
                window.webkitCancelRequestAnimationFrame ||
                window.mozCancelRequestAnimationFrame ||
                window.oCancelRequestAnimationFrame ||
                window.msCancelRequestAnimationFrame ||
                clearTimeout
        })();


        // Initialize canvas and required variables
        var canvas = document.getElementById("canvas"),
            ctx = canvas.getContext("2d"), // Create canvas context
            W = 1250, //window.innerWidth, // Window's width
            H = 800, //window.innerHeight, // Window's height
            particles = [], // Array containing particles
            ball = {}, // Ball object
            paddles = [2], // Array containing two paddles
            mouse = {}, // Mouse object to store it's current position
            points = 0, // Varialbe to store points
            fps = 60, // Max FPS (frames per second)
            particlesCount = 20, // Number of sparks when ball strikes the paddle
            flag = 0, // Flag variable which is changed on collision
            particlePos = {}, // Object to contain the position of collision
            multipler = 1, // Varialbe to control the direction of sparks
            startBtn = {}, // Start button object
            restartBtn = {}, // Restart button object
            over = 0, // flag varialbe, cahnged when the game is over
            init, // variable to initialize animation
            paddleHit;

        // Add mousemove and mousedown events to the canvas
        canvas.addEventListener("mousedown", btnClick, true);

        // Initialise the collision sound
        collision = document.getElementById("collide");

        // Set the canvas's height and width to full screen
        canvas.width = W;
        canvas.height = H;
        mouse.x = W / 2;


        var myMyo;

        Myo.on('connected', function () {
            myMyo = this;
            Myo.setLockingPolicy("none");
            myMyo.unlock();
            addEvents(myMyo);
        });

        Myo.connect();

        var tempHelper = 0;

        var addEvents = function (myo) {
            myo.on("imu",
                function (data) {
                    processIMU(data);
                    if (tempHelper >= 10000) {
                        tempHelper = 0;
                        return;
                    }
                    tempHelper++;
                    if (!mouse.x) return;
                    mouse.x += Math.floor(data.gyroscope.y*0.99);
                    console.log("mouse.x = " + mouse.x);
                });
            myo.on('connected', function () {
                myo.streamEMG(true);
            });
            myo.on('emg', function (data) {
                processEMG(data);
            });
            myo.on('pose',
                function (name) {
                    if (name == "double_tap") {
                        if (over == 1) {
                            ball.x = 20;
                            ball.y = 20;
                            points = 0;
                            ball.vx = 4;
                            ball.vy = 4;
                            animloop();
                            over = 0;
                        }
                        else if (over == 0 && startBtn.x) {
                            animloop();
                            startBtn = {};
                        }
                    }
                });
        }

        // Function to paint canvas
        function paintCanvas() {
            ctx.fillStyle = "#f2f2f2";
            ctx.fillRect(0, 0, W, H);
        }

        // Function for creating paddles
        function Paddle(pos) {
            // Height and width
            this.h = 7;
            this.w = 160;

            // Paddle's position
            this.x = W / 2 - this.w / 2;
            this.y = (pos == "top") ? 0 : H - this.h;

        }

        // Push two new paddles into the paddles[] array
        paddles.push(new Paddle("bottom"));
        paddles.push(new Paddle("top"));

        // Ball object
        ball = {
            x: 50,
            y: 50,
            r: 5,
            c: "#0a006b",
            vx: 4,
            vy: 4,

            // Function for drawing ball on canvas
            draw: function () {
                ctx.beginPath();
                ctx.fillStyle = this.c;
                ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2, false);
                ctx.fill();
            }
        };


        // Start Button object
        startBtn = {
            w: 100,
            h: 50,
            x: W / 2 - 50,
            y: H / 2 - 25,

            draw: function () {
                ctx.strokeStyle = "#0a006b";
                ctx.lineWidth = "2";
                ctx.strokeRect(this.x, this.y, this.w, this.h);

                ctx.font = "18px Arial, sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStlye = "#0a006b";
                ctx.fillText("Jugar", W / 2, H / 2);
            }
        };

        // Restart Button object
        restartBtn = {
            w: 100,
            h: 50,
            x: W / 2 - 50,
            y: H / 2 - 50,

            draw: function () {
                ctx.strokeStyle = "#0a006b";
                ctx.lineWidth = "2";
                ctx.strokeRect(this.x, this.y, this.w, this.h);

                ctx.font = "18px Arial, sans-serif";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillStlye = "#0a006b";
                ctx.fillText("Jugar", W / 2, H / 2 - 25);
            }
        };

        // Function for creating particles object
        function createParticles(x, y, m) {
            this.x = x || 0;
            this.y = y || 0;

            this.radius = 1.2;

            this.vx = -1.5 + Math.random() * 3;
            this.vy = m * Math.random() * 1.5;
        }

        // Draw everything on canvas
        function draw() {
            paintCanvas();
            for (var i = 0; i < paddles.length; i++) {
                p = paddles[i];

                ctx.fillStyle = "#0a006b";
                ctx.fillRect(p.x, p.y, p.w, p.h);
            }

            ball.draw();
            update();
        }

        // Function to increase speed after every 5 points
        function increaseSpd() {
            if (points % 4 == 0) {
                if (Math.abs(ball.vx) < 15) {
                    ball.vx += (ball.vx < 0) ? -1 : 1;
                    ball.vy += (ball.vy < 0) ? -2 : 2;
                }
            }
        }

        // Function to update positions, score and everything.
        // Basically, the main game logic is defined here
        function update() {

            // Update scores
            updateScore();

            // Move the paddles on mouse move
            if (mouse.x) {
                for (var i = 1; i < paddles.length; i++) {
                    p = paddles[i];
                    if (mouse.x - p.w / 2 < 0) {
                        mouse.x = p.w / 2;
                    }
                    if (mouse.x + p.w / 2 > W) {
                        mouse.x = W - p.w / 2;
                    }
                    p.x = mouse.x - p.w / 2;
                }
            }

            // Move the ball
            ball.x += ball.vx;
            ball.y += ball.vy;

            // Collision with paddles
            p1 = paddles[1];
            p2 = paddles[2];

            // If the ball strikes with paddles,
            // invert the y-velocity vector of ball,
            // increment the points, play the collision sound,
            // save collision's position so that sparks can be
            // emitted from that position, set the flag variable,
            // and change the multiplier
            if (collides(ball, p1)) {
                collideAction(ball, p1);
            }


            else if (collides(ball, p2)) {
                collideAction(ball, p2);
            }

            else {
                // Collide with walls, If the ball hits the top/bottom,
                // walls, run gameOver() function
                if (ball.y + ball.r > H) {
                    ball.y = H - ball.r;
                    gameOver();
                }

                else if (ball.y < 0) {
                    ball.y = ball.r;
                    gameOver();
                }

                // If ball strikes the vertical walls, invert the
                // x-velocity vector of ball
                if (ball.x + ball.r > W) {
                    ball.vx = -ball.vx;
                    ball.x = W - ball.r;
                }

                else if (ball.x - ball.r < 0) {
                    ball.vx = -ball.vx;
                    ball.x = ball.r;
                }
            }



            // If flag is set, push the particles
            if (flag == 1) {
                for (var k = 0; k < particlesCount; k++) {
                    particles.push(new createParticles(particlePos.x, particlePos.y, multiplier));
                }
            }

            // Emit particles/sparks
            emitParticles();

            // reset flag
            flag = 0;
        }

        //Function to check collision between ball and one of
        //the paddles
        function collides(b, p) {
            if (b.x + ball.r >= p.x && b.x - ball.r <= p.x + p.w) {
                if (b.y >= (p.y - p.h) && p.y > 0) {
                    paddleHit = 1;
                    return true;
                }

                else if (b.y <= p.h && p.y == 0) {
                    paddleHit = 2;
                    return true;
                }

                else return false;
            }
        }

        //Do this when collides == true
        function collideAction(ball, p) {
            ball.vy = -ball.vy;

            if (paddleHit == 1) {
                ball.y = p.y - p.h;
                particlePos.y = ball.y + ball.r;
                multiplier = -1;
            }

            else if (paddleHit == 2) {
                ball.y = p.h + ball.r;
                particlePos.y = ball.y - ball.r;
                multiplier = 1;
            }

            points++;
            _finalScore++;
            increaseSpd();

            if (collision) {
                if (points > 0)
                    collision.pause();

                collision.currentTime = 0;
                collision.play();
            }

            particlePos.x = ball.x;
            flag = 1;
        }

        // Function for emitting particles
        function emitParticles() {
            for (var j = 0; j < particles.length; j++) {
                par = particles[j];

                ctx.beginPath();
                ctx.fillStyle = "#001435";
                if (par.radius > 0) {
                    ctx.arc(par.x, par.y, par.radius, 0, Math.PI * 2, false);
                }
                ctx.fill();

                par.x += par.vx;
                par.y += par.vy;

                // Reduce radius so that the particles die after a few seconds
                par.radius = Math.max(par.radius - 0.05, 0.0);

            }
        }

        // Function for updating score
        function updateScore() {
            ctx.fillStlye = "#0a006b";
            ctx.font = "17px Arial, sans-serif";
            ctx.textAlign = "left";
            ctx.textBaseline = "top";
            ctx.fillText("Puntos: " + points, 20, 20);
        }

        // Function to run when the game overs
        function gameOver() {
            ctx.fillStlye = "#001435";
            ctx.font = "20px Arial, sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("Fin del Juego", W / 2, H / 2 + 25);

            // Stop the Animation
            cancelRequestAnimFrame(init);

            // Set the over flag
            over = 1;

            // Show the restart button
            restartBtn.draw();
        }

        // Function for running the whole animation
        function animloop() {
            init = requestAnimFrame(animloop);
            draw();
        }

        // Function to execute at startup
        function startScreen() {
            draw();
            startBtn.draw();
        }

        // On button click (Restart and start)
        function btnClick(e) {
            var rect = canvas.getBoundingClientRect();

            // Variables for storing mouse position on click
            var mx = e.clientX - rect.left, my = e.clientY - rect.top;

            // Click start button
            if (mx >= startBtn.x && mx <= startBtn.x + startBtn.w) {
                animloop();

                // Delete the start button after clicking it
                startBtn = {};
            }

            // If the game is over, and the restart button is clicked
            if (over == 1) {
                if (mx >= restartBtn.x && mx <= restartBtn.x + restartBtn.w) {
                    ball.x = 20;
                    ball.y = 20;
                    points = 0;
                    ball.vx = 4;
                    ball.vy = 4;
                    animloop();

                    over = 0;
                }
            }
        }

        // Show the start screen
        startScreen();
    </script>
}


